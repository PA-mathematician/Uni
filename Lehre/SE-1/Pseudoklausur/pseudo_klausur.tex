\documentclass[11pt,a4paper,oneside,ngerman]{scrbook}

\usepackage[utf8x]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\pagestyle{empty}

\usepackage{enumitem}
\usepackage{wasysym}
\usepackage{graphicx}

% for code
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}

% for tree diagrams
\usepackage{qtree}

\begin{document}

\thispagestyle{empty}
\begin{center}
\Large{\LARGE{Pseudoklausur SE-1, WS-2011/12}}
\end{center}
\begin{verbatim}





\end{verbatim}
\begin{center}
\textbf{{zu Übungs- und Vorbereitungszwecken\\}}
\textbf{{von Manuel Hoffmann}}
\end{center}
\begin{verbatim}


\end{verbatim}
\begin{center}
\textbf{Diese Pseudoklausur soll lediglich eine zusätzliche Ansammlung an Übungsaufgaben sein, deren Stil
auch in einer richtigen Klausur drankommen können. Die Auswahl der Aufgaben soll kein Hinweis darauf sein,
welche Aufgaben in der richtigen Klausur drankommen.}
\end{center}



\newpage

\section{Multiple Choice}
Ja Nein
\begin{itemize}[label={\Square \ \Square}]
  \item Ein Programm, dessen Korrektheit bewiesen wurde, terminiert immer. % nö
  \item Anforderungen an ein Softwaresystem können funktional und nicht-funktional sein. % ja
  \item Eine Zeichenreihe ist eine endliche oder unendliche Folge von Zeichen. % nö
  \item Eine Sprachdefinition mit Syntaxdiagramm kann ein Startsymbol enthalten. %nö
  \item Die Mächtigkeit der Menge der Produktionen ist bei einer kontextfreien Grammatik immer kleiner als die Mächtigkeit der Terminalsymbolen. %nö
  \item Ein Satz ist genau dann eindeitig, wenn er genau eine Rechtsableitung besitzt. %ja 
  \item Es gibt formale Sprachen ohne Semantik. %ja
  \item Zwei Sprachen mit unterschiedlichen Produktionsregeln können nie gleich sein. %nö
  \item Eine partielle Funktion ist auf mindestens einem Element ihres Argumentbereichs definiert. %nö
  \item Bezeichner einer Programmiersprache können überladen sein. %ja
  \item Deklarationen dienen dazu, einem in einem Programm verwendeten Element einen Wert zuzuweisen. %nö
  \item Eine Funktionsdeklaration heißt direkt rekursiv, wenn der definierende Ausdruck eine Anwendung der definierten Funktion enthält. %ja
  \item Eine repetitive Funktionsdeklaration ist linear rekursiv. %ja
  \item Ein Typ mit Typvariablen ist immer spezieller als ein Typ ohne Typvariablen. %nö
  \item Ein Programm, das richtige Ergebinsse liefert, wenn es terminiert heißt partiell korrekt. %ja
  \item Mit Parameterinduktion kann man direkt zeigen, dass ein Programm terminiert. % nö
  \item Bei einem Terminierungsbeweis muss man lediglich zeigen, dass man aus der Menge der zulässigen Parameter bijektiv in eine noethersche Ordnung abbilden kann. %nö
  \item Ein Algorithmus, der für gleiche Eingabedaten immer gleich abläuft, heißt deterministisch. %ja
  \item Ein Algorithmus, der für verschiedene Eingabedaten immer das gleiche Ergebnis ausliefert, heißt determiniert. %ja
  \item Die Schleifenanweisung einer for-Schleife kann ohne weitere Änderungen durch die einer while-Schleife ersetzt werden. %nein
  \item Die Schleifenanweisung einer while-Schleife kann ohne weitere Änderungen durch die einer for-Schleife ersetzt werden. %ja


  \item Wird ein Objekt persistent gemacht, kann man 
\end{itemize}


\newpage

\section{Funktionale Programmierung}


\emph{(a)} Ihnen sind die folgenden Funktionsdefinitionen gegeben, jedoch fehlen die Signaturen. Ergänzen Sie die Signaturen mit dem allgemeinstmöglichen Typ.
\begin{code}
  a :: t -> (t -> Bool) -> t -> Bool

  a x y z = (y x) && (y z)

  
  b :: Num a => a -> [a] -> t
  
  b x y = b (x + head y) (tail y)

  
  c :: [a] -> [a] -> [a]
  
  c x (y:z) = c [y] x ++ z

  
  d :: t1 -> [t1 -> t1] -> t

  d x (y:z) = d (y x) z
\end{code}



\emph{(b)} Implementieren Sie die Funktion \emph{foldl}, die mit Hilfe einer Funktion und einem Startwert eine Liste von links ausgehend zu einem Ergebnis zusammenfaltet.

\begin{code}
  foldl :: 


\end{code}

Implementieren Sie die Funktion \emph{foldr}, die mit Hilfe einer Funktion und einem Startwert eine Liste von rechts ausgehend zu einem Ergebnis zusammenfaltet.

\begin{code}
  foldr :: 


\end{code}

Implementieren Sie die Funktion \emph{map}, die eine Funktion und eine Liste von Werten nimmt und als Ergebnis eine Liste mit den Funktionswerten liefert. Beispiele:
\begin{code}
  map ((+) 3) [0,1,2,3]             => [3,4,5,6]
  map length [[], [2,3,4], [2,1]]   => [0,3,2]

  map :: 


\end{code}

\newpage



\section{Funktionale Programmierung}
Gegeben sei der folgende Datentyp, der einen Binärbaum darstellt, dessen Knoten und Blätter mit Bruchzahlen markiert sind.

\begin{code}
data FracTree = FracNode FracTree FracTree Integer Integer 
              | FracLeaf Integer Integer
\end{code}

Der erste Integer entspricht dem Zähler, der zweite dem Nenner; d.h.
\begin{code} 
(FracLeaf 5 7)
\end{code}
entspricht dem Bruch: $\frac57$
\\
\\
\emph{(a)} Implementieren Sie eine Funktion \emph{countN}, die zählt, wie viele Knoten eines \emph{FracTree} natürliche Zahlen sind. Geben Sie auch eine sinnvolle Signatur an.
Beispiele:
\begin{code}
  countN (FracNode (FracLeaf 2 5) (FracLeaf 2 1) 3 8) == 1
  countN (FracNode (FracLeaf 12 3) (FracLeaf 14 7) 2 4) == 2







\end{code}

\emph{(b)} Implementieren Sie eine Funktion \emph{infty}, die testet, ob ein FracTree einen Bruch mit Nenner 0 enthält. Geben Sie auch eine sinnvolle Signatur an.
Beispiele:
\begin{code}
  infty (FracNode (FracLeaf 2 5) (FracLeaf 2 1) 3 8) == False
  infty (FracNode (FracLeaf 2 5) (FracLeaf 2 0) 3 8) == True









\end{code}

\newpage


\section{Funktionale Programmierung}

Gegeben ist eine Datenstruktur \emph{ListTree}, die einen Binärbaum darstellt, dessen Knoten und Blätter mit Listen von Integern markiert sind. Diese Datenstruktur verfügt über die Konstruktoren \emph{ListNode ListTree ListTree [Integer]} und \emph{ListLeaf [Integer]}.
Außerdem ist die Datenstruktur \emph{IntTree} mit Integer-Markierungen gegeben. Diese hat die Konstruktoren \emph{IntNode IntTree IntTree Integer} und \emph{IntLeaf Integer}.
\\
\\
\emph{(a)} Schreiben Sie eine Funktion \emph{sumUpToIntTree}, die einen ListTree bekommt und einen IntTree zurückgibt. Dabei soll an jeder entsprechenden Markierung des zurückgegebenen Baumes die Summe der Werte des Eingabebaums stehen. Vergessen Sie die Signatur nicht. Beispiel:

\begin{minipage}[btm]{5cm}
%\centering
\Tree
  [ .[1,2,1]
    [ .[2,3]
      [ [ .[1,3] ]
        [ .[2,4,3] ]
      ]
    ]
    [ .[3,4] ]
  ]

\end{minipage}
\begin{minipage}[btm]{1.4cm}
wird zu
\end{minipage}
\begin{minipage}[btm]{5cm}
%\centering
\Tree
  [ .4
    [ .5
      [ [ .4 ]
        [ .9 ]
      ]
    ]
    [ .7 ]
  ]

\end{minipage}

\begin{code}


  sumUpToIntTree ::
\end{code}

\newpage


\section{Sprachen}
\emph{(a)} Betrachten Sie folgende (unvollständige) Sprachdefinition mit Syntaxdiagrammen:

\begin{figure}[htbp]
  \includegraphics[height=5.5cm]{insert-stmt.png}
  \caption{Insert-Statement von SQLite}
\end{figure}
\emph{database-name}, \emph{table-name} und \emph{column-name} sollen dabei Konkatenationen von Groß- und Kleinbuchstaben sein, d.h. insbesondere keine Leer- und Sonderzeichen enthalten, ebenso für die Ausdrücke des nicht dargestellten Diagramms \emph{expr}. Das weiterhin nicht dargestellte Diagramm \emph{select-stmt} können Sie vernachlässigen.

Kreuzen Sie diejenigen Worte an, die mit dieser Sprachdefinition gebildet werden können.
\begin{itemize}[label={\Square}]
  \item REPLACE OR ABORT INTO mytable DEFAULT VALUES
  \item INSERT INTO mydatabase DEFAULT VALUES
  \item INSERT OR FAIL INTO mydb.mytbl (INSERT, OR, FAIL) VALUES (mydb, mytbl)
  \item insert into MYDATABASE default values
\end{itemize}


\emph{(b)} Definieren Sie eine Grammatik, deren erzeugte Sprache nur das leere Wort enthält.


\newpage



\section{Terminierung}

\emph{(a)} Geben Sie für folgende Funktionen je die größtmögliche Parametermenge an, sodass sie terminieren

\begin{code}
  f :: Int -> String -> Int
  f 0 _ = 77
  f x y = f (x - 1 + length y) (tail y)
\end{code}

\begin{code}
  g :: Int -> String -> Int
  g 0 _ = 77
  g _ "" = 88
  g x y = g (x - 1 + length y) (tail y)
\end{code}

\begin{code}
  h :: Int -> String -> Int
  h _ "" = 88
  h 0 _ = 77
  h x y = h (x - 1 + length y) (tail y ++ tail y)
\end{code}


\emph{(b)} Geben Sie für die folgende Funktion den größtmöglichen Parameterbereich an und beweisen sie, dass sie terminiert:

\begin{code}
t :: Int -> Int -> Int
t 0 0 = 0
t 0 x = t x + (x `div` 2)
t x y = y * (t (x - (x `div` 2)) (x + x `div` 2))
\end{code}

\newpage

\section{Prozedurale Programmierung}
Gegeben sind folgende Datenstrukturen:

\begin{code}
class Vektor {
  double[] values;
}

class Matrix {
  double[][] values;
}
\end{code}

Schreiben Sie eine Prozedur \emph{skalarMat(Vektor x, Vektor y, Matrix A)}, die das wie folgt definierte Skalarprodukt berechnet: $\langle x, y\rangle_A  =  x^TAy$.

Dabei bezeichnet $x^T$ den transponierten Vektor; die Matrixmultiplikation ist rechtsassoziativ.

\begin{code}
  double skalarMat(Vektor x, Vektor y, Matrix A) {
    
  
\end{code}

\newpage

\section{Prozedurale Programmierung}

Eine logische Variable hat einen Namen und kann mit \emph{true} oder \emph{false} belegt sein kann. Ein Literal ist eine logische Variable oder deren Negation (mit $\neg$). Eine disjuktive Verknüpfung (mit $\lor$) von Literalen heißt \emph{Klausel}, eine konjunktive Verknüpfung von Klauseln (mit $\land$) heißt \emph{Konjunktive Normalform (KNF)}.


Die Verknüpfungen sind wie folgt definiert:


\begin{tabular}[ht]{|c|c|c|c|} %{|l|c|}
  \hline
  a & b & a $\land$ b & a $\lor$ b\\
  \hline
  False & False & False & False\\
  False & True & False & True\\
  True & False & False & True\\
  True & True & True & True\\
  \hline
\end{tabular}


Das Ziel der Aufgabe ist es, Prozeduren auf Formeln in konjunktver Normalform anzuwenden. Beispiele für KNF:
\begin{gather*}
  (a \lor b \lor \neg c) \land ( \neg b \lor c) \\
  (\neg a \lor \neg b \lor c ) \land c \land (a \lor b \lor c)
\end{gather*}

\emph{(a)} Modellieren Sie Datenstrukturen für:
\begin{enumerate}
  \item Variable
  \item Literal
  \item Klausel mit max. 10 Literalten
  \item KNF mit max. 10 Klauseln
\end{enumerate}

\emph{(b)} Schreiben sie eine Prozedur \emph{simplify}, die als Parameter eine KNF nimmt und dabei Klauseln streicht, in denen ein Literal und seine Negation vorkommen, und Literale streicht, die doppelt vorkommen. Beispiel:
\begin{gather*}
  (a \lor \neg a \lor b) \land (a \lor \neg b \lor a) \overset{\text{simplify}}\Rightarrow (a \lor \neg b)
\end{gather*}

\emph{(c)} Schreiben Sie eine Prozedur \emph{eval}, die als Parameter eine KNF nimmt, und logisch auswertet. Das heißt, je nachdem wie die Variablen belegt sind, soll ein anderer Wahrheitswert zurückgegeben werden. Beispiel:
\begin{gather*}
  a, b := \text{True}, c := \text{False} \\
  (a \lor b \lor \neg c) \land ( \neg b \lor c) = True \land False = False \\
  (\neg a \lor \neg b \lor c ) \land c \land (a \lor b \lor c) = False \land False \land True = False
\end{gather*}




\newpage

\section{Objektorientierte Modellierung}
\emph{(a)} Modellieren Sie folgendes Szenario als UML-Klassendiagramm mit Attributen und Methoden. Vergessern Sie die Multiplizitäten dabei nicht. Treffen Sie für nicht angegebene Informationen vernünftige Annahmen.

In einem Handballverein sind Mitglieder entweder Spieler oder Trainer. Alle Mitglieder haben einen Namen und eine Mitgliedsnummer. Spieler haben zusätzlich eine Spielernummer. Der Verein hat mehrere Mannschaften, die alle einen Trainer und einen Co-Trainer haben.


\newpage

\emph{(b)} Ergänzen Sie ihr UML-Diagramm um weitere Klassen gemäß der folgenden Beschreibung. Dabei brauchen Sie Attribute und Methoden nicht einzeichnen.

Wir betrachten jetzt den Handballverband. In ihm gibt es mehrere Ligen, in denen jeweils die Mannschaften mehrerer Vereine spielen. Dies tun sie in Hallen. Jedem Verein werden Hallen zur Verfügung gestellt, die dann in einem Spiel die Heimhalle sind.


\newpage

\section{Objektorientierte Programmierung - Implementierung}
Sie haben in der Übung bereits gebräuchliche Datenstrukturen implementiert. Dabei fehlt bisher noch die \emph{Menge}.
Eine Menge hat folgende Eigenschaften:

\begin{enumerate}
  \item Eine Menge besteht aus Elementen eines Typs T
  \item Eine Menge kann leer sein
  \item Eine Menge ist duplikatfrei
  \item Mit der Methode \emph{add(T t)} wird ein neues Element der Menge hinzugefügt
  \item Mit der Methode \emph{remove(T t)} wird das Element t - falls vorhanden - aus der Menge entfernt
  \item Damit man die Daten einfach auch mit anderen Algorithmen benutzen kann, gibt die Methode \emph{toArray()} alle (noch nicht gelöschten) Elemente der Menge zurück.
\end{enumerate}


\end{document}